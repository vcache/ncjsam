/*
    This file was auto-generated by NCJSAM ver. 0.1 at 2023-09-26T16:43:18.940447Z.
    It is a part of the "Sprites Example" ver. 1.0.

    The Authors of the "Sprites Example" are:
      - Igor Berezniak

    (C) Copyright 2023 by Authors.
*/

import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// TODO: these are optional, don't include when not required
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
import { CSS3DRenderer, CSS3DObject, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';

/* API class */

class API {
    constructor() { }

    __setMain(main) { this._main = main; }

    timestamp = () => { return this._main.getWallclock(); }
    dt = () => { return this._main.getLastDt(); }
    camera = () => { return this._main.getCamera(); }
    renderer = () => { return this._main.getRenderer(); }
    width = () => { return window.innerWidth; }
    height = () => { return window.innerHeight; }
    enqueue = (kind, args) => { this._main.enqueue(kind, args); }

    play = (filename, volume) => {
        const sound = new Audio(filename);
        sound.volume = volume;
        return sound.play();
    }

    pointerIntersections = () => {
        return this._main.getPointerIntersections();
    }
}

const $ = new API();

/* Generated classes */

class EntityBase {
    constructor(entity_id, full_path, assetsManager, parent) {
        this._entity_id = entity_id;
        this._full_path = full_path;
        this._assetsManager = assetsManager;
        this._parent = parent;
        // TODO: transfer context value from parent if any
    }

    // TODO: maybe property?
    setContextValue(variable_name, variable_data) {
        // TODO: filter builtin names
        this[variable_name] = variable_data;
        if (this._transformer) {
            this._transformer[variable_name] = variable_data;
        }
        this._name_of_variable_name = variable_name;
    }

    setTransformer(transformer) {
        this._transformer = transformer;
        if (this._transformer) {
            if (this._name_of_variable_name) {
                this._transformer[this._name_of_variable_name] = this[this._name_of_variable_name];
            }
            this._transformer.initValues();
        }
    }

    onStep(sync) /* virtual */ {
        const visible = this.evalProperty__visible(); // TODO: dont' evaluate when 'visible' is static
        if (visible != this._visible) {     // TODO: don't need to eval this on every iteration
            this.onVisibleChanged(visible);
        }
        if (visible && this._transformer) {
            this._transformer.updateValues();
        }
        // TODO: prune the tree (i.e. when all descendants are static entities)
    }

    onEmerge(viewContainer, guiContainer) /* virtual */ {
        this._visible = this.evalProperty__visible();
    }
    
    onUnmerge() /* virtual */ {
        this._visible = null;
        this._transformer = null;
        this[this._name_of_variable_name] = null;
        this._name_of_variable_name = null;
    }

    onResize(width, height) /* virtual */ {}
    
    onVisibleChanged(visible) /* virtual */ {
        this._visible = visible;
    }

    onEventPosted(kind, args) /* virtual */ {}

    getSubscribedEvents() /* virtual */ { return new Set(); }

    query(target, params) /* virtual */ { return null; }

    getFullPath() { return this._full_path; }

    getEntityId() { return this._entity_id; }

    registerEntity(destination_object) /* virtual */ {
        destination_object[this._full_path] = this;    // TODO: put wrapper instead 'this'
    }

    dump() {
        const result = {
            'entity-id': this._entity_id,
            'full-path': this.getFullPath(),
            'visible': this._visible, //  TODO: maybe useless?
        };
        if (this._name_of_variable_name) {
            result['context-value'] = {
                'name': this._name_of_variable_name,
                'value': this[this._name_of_variable_name],
            };
        }
        return result;
    }

    restore(state_dump) {
        // TODO: validate state_dump
        this._visible = state_dump['visible'];
        const contextValue =  state_dump['context-value'];
        if (contextValue) {
            this.setContextValue(contextValue['name'],
                                 contextValue['value']);
        }
    }
}

/* sprites_debug_grid */

class sprites_debug_grid_Transformer {
    static kTrivial = true;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_debug_grid extends EntityBase {
        evalProperty__divisions() {  // property is static
        return 10;
    }
    evalProperty__size() {  // property is static
        return 10;
    }
    evalProperty__visible() {  // property is static
        return true;
    }



    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {
        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        if (!this._size) this._size = this.evalProperty__size();
        if (!this._divisions) this._divisions = this.evalProperty__divisions();
        this._helper = new THREE.GridHelper(this._size,
                                            this._divisions);
        this._helper.name = this.getFullPath();
        this._helper.userData = {
            'treeNode': this,
        }
        this._helper.visible = this._visible;
        if (viewContainer) {
            viewContainer.add(this._helper);
        }
        this.setTransformer(new sprites_debug_grid_Transformer(this._helper, this));
    }

    onUnmerge() {
        this._size = null;
        this._divisions = null;
        this._helper.removeFromParent();
        this._helper.dispose();
        this._helper = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._helper.visible = visible;
    }
}

/* sprites_box_with_text_some_box */

class sprites_box_with_text_some_box_Transformer {
    static kTrivial = true;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_text_some_box extends EntityBase {
        evalProperty__animation() {  // property is static
        return null;
    }
    evalProperty__filename() {  // property is static
        return "mesh.glb";
    }
    evalProperty__visible() {  // property is static
        return true;
    }

        buildMaterial() {
        const parameters = {
            aoMapIntensity: (() => {
                return 1;
            })(),
            bumpScale: (() => {
                return 1;
            })(),
            color: (() => {
                return new THREE.Color(1, 1, 1);
            })(),
            displacementScale: (() => {
                return 1;
            })(),
            emissive: (() => {
                return new THREE.Color(0, 0, 0);
            })(),
            emissiveIntensity: (() => {
                return 1;
            })(),
            envMapIntensity: (() => {
                return 1;
            })(),
            fog: (() => {
                return true;
            })(),
            lightMapIntensity: (() => {
                return 1;
            })(),
            normalMapType: (() => {
                return THREE.TangentSpaceNormalMap;
            })(),
            normalScale: (() => {
                return new THREE.Vector2(1, 1);
            })(),
            roughness: (() => {
                return 1.0;
            })(),
            wireframeLinecap: (() => {
                return "round";
            })(),
            wireframeLinejoin: (() => {
                return "round";
            })(),
            wireframeLinewidth: (() => {
                return 1;
            })(),
        };
        return new THREE.MeshStandardMaterial(parameters);
    }


    recalcMaterialProps(target) {
    }


    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {


            if (this._mixer) {
                this._mixer.update($.dt());
            }
        }
    }

    listAnimations() {
        const result = [];
        for(var i in this._animations) {
            result.push(this._animations[i].name);
        }
        return result;
    }

    // THREE.LoopOnce | THREE.LoopRepeat | THREE.LoopPingPong
    playAnimation(animation, loop = THREE.LoopOnce) {
        if (this._mixer) {
            const clip = THREE.AnimationClip.findByName(this._animations, animation);
            if (clip) {
                const action = this._mixer.clipAction(clip);
                action.reset();
                action.loop = loop;
                action.play();
            } else {
                console.log(`no such animation clip: ${animation}`);
            }
        }
    }

    resetAnimation() {
        this._mixer.stopAllAction();
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._viewContainer = viewContainer;
        this._guiContainer = guiContainer;
        if (this._visible) {
            if (!this._filename) this._filename = this.evalProperty__filename();
            const asset = this._assetsManager.getAsset(this._filename);
            if (!asset) throw Error(`no such mesh: ${this._filename}`)
            this._scene = asset.scene.clone();

            this._scene.userData = {
                'treeNode': this,
            }
            for(var i in this._scene.children) {
                this._scene.children[i].userData = {
                    'treeNode': this,
                }
            }

            this._scene.visible = this._visible;
            if (viewContainer) { // TODO: move to base class
                viewContainer.add(this._scene);
            }
            this.setTransformer(new sprites_box_with_text_some_box_Transformer(this._scene, this));

            // NOTE: disable "Group by NLA Track"
            if (asset.animations.length > 0) {
                this._mixer = new THREE.AnimationMixer(this._scene);
                this._animations = asset.animations;
            } else {
                this._mixer = null;
            }

            this._animation = this.evalProperty__animation();
            if (this._animation) {
                this.playAnimation(this._animation, THREE.LoopRepeat);
            }
        }
    }

    onUnmerge() {
        this._filename = null;
        if (this._scene) {
            this._scene.removeFromParent();
        }
        this._scene = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        if (this._scene) {
            this._scene.visible = visible;
        } else {
            // TODO: this is ugly
            this.onEmerge(this._viewContainer, this._guiContainer);
        }
    }
}

/* sprites_box_with_text_label_2d */

class sprites_box_with_text_label_2d_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(0, -2, 0);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_text_label_2d extends EntityBase {
        evalProperty__mode() {  // property is static
        return "2d";
    }
    evalProperty__style() {  // property is static
        return "font-family: monospace;\nfont-size: 10px;\ncolor: #EEEEEE;\nbackground: #444444;\npadding: 5px;\nborder: 1px yellow solid;\n";
    }
    evalProperty__text() {  // property is dynamic
        return `2d text bar: ${$.timestamp()}`

    }
    evalProperty__visible() {  // property is static
        return true;
    }

    

    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

            const text = this.evalProperty__text();
            if (text !== this._text) {
                this._text = text;
                this._domElement.textContent = text;
            }

        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._domElement = document.createElement('div');

        if (!this._text) this._text = this.evalProperty__text();
        if (!this._style) this._style = this.evalProperty__style();
        this._domElement.textContent = this._text;
        this._domElement.style.cssText = this._style;

        const mode = this.evalProperty__mode();
        if (mode === '2d') {
            this._cssObject = new CSS2DObject(this._domElement);
        } else if (mode === '3d-faced') {
            this._cssObject = new CSS3DSprite(this._domElement);
        } else if (mode === '3d') {
            this._cssObject = new CSS3DObject(this._domElement);
        } else {
            throw new Error(`unknown sprite mode: ${mode}`);
        }
        this._cssObject.visible = this._visible;

        if (viewContainer) { // TODO: move to base class
            viewContainer.add(this._cssObject);
        }

        this.setTransformer(new sprites_box_with_text_label_2d_Transformer(this._cssObject, this));
    }

    onUnmerge() {
        this._cssObject.removeFromParent();
        this._cssObject = null;
        this._domElement = null;
        this._text = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._cssObject.visible = visible;
    }
}

/* sprites_box_with_text_label_3d */

class sprites_box_with_text_label_3d_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(0, 2, 0);
        this._object.scale.set(0.05, 0.05, 0.05);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_text_label_3d extends EntityBase {
        evalProperty__mode() {  // property is static
        return "3d";
    }
    evalProperty__style() {  // property is static
        return "font-family: monospace;\nfont-size: 10px;\ncolor: #EEEEEE;\nbackground: #444444;\npadding: 5px;\nborder: 1px yellow solid;\n";
    }
    evalProperty__text() {  // property is dynamic
        return `3d text bar: ${$.timestamp()}`

    }
    evalProperty__visible() {  // property is static
        return true;
    }

    

    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

            const text = this.evalProperty__text();
            if (text !== this._text) {
                this._text = text;
                this._domElement.textContent = text;
            }

        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._domElement = document.createElement('div');

        if (!this._text) this._text = this.evalProperty__text();
        if (!this._style) this._style = this.evalProperty__style();
        this._domElement.textContent = this._text;
        this._domElement.style.cssText = this._style;

        const mode = this.evalProperty__mode();
        if (mode === '2d') {
            this._cssObject = new CSS2DObject(this._domElement);
        } else if (mode === '3d-faced') {
            this._cssObject = new CSS3DSprite(this._domElement);
        } else if (mode === '3d') {
            this._cssObject = new CSS3DObject(this._domElement);
        } else {
            throw new Error(`unknown sprite mode: ${mode}`);
        }
        this._cssObject.visible = this._visible;

        if (viewContainer) { // TODO: move to base class
            viewContainer.add(this._cssObject);
        }

        this.setTransformer(new sprites_box_with_text_label_3d_Transformer(this._cssObject, this));
    }

    onUnmerge() {
        this._cssObject.removeFromParent();
        this._cssObject = null;
        this._domElement = null;
        this._text = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._cssObject.visible = visible;
    }
}

/* sprites_box_with_text_label_3d_faced */

class sprites_box_with_text_label_3d_faced_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(0, 0, 0);
        this._object.scale.set(0.05, 0.05, 0.05);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_text_label_3d_faced extends EntityBase {
        evalProperty__mode() {  // property is static
        return "3d-faced";
    }
    evalProperty__style() {  // property is static
        return "font-family: monospace;\nfont-size: 10px;\ncolor: #EEEEEE;\nbackground: #444444;\npadding: 5px;\nborder: 1px yellow solid;\n";
    }
    evalProperty__text() {  // property is dynamic
        return `3d text bar: ${$.timestamp()}`

    }
    evalProperty__visible() {  // property is static
        return true;
    }

    

    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

            const text = this.evalProperty__text();
            if (text !== this._text) {
                this._text = text;
                this._domElement.textContent = text;
            }

        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._domElement = document.createElement('div');

        if (!this._text) this._text = this.evalProperty__text();
        if (!this._style) this._style = this.evalProperty__style();
        this._domElement.textContent = this._text;
        this._domElement.style.cssText = this._style;

        const mode = this.evalProperty__mode();
        if (mode === '2d') {
            this._cssObject = new CSS2DObject(this._domElement);
        } else if (mode === '3d-faced') {
            this._cssObject = new CSS3DSprite(this._domElement);
        } else if (mode === '3d') {
            this._cssObject = new CSS3DObject(this._domElement);
        } else {
            throw new Error(`unknown sprite mode: ${mode}`);
        }
        this._cssObject.visible = this._visible;

        if (viewContainer) { // TODO: move to base class
            viewContainer.add(this._cssObject);
        }

        this.setTransformer(new sprites_box_with_text_label_3d_faced_Transformer(this._cssObject, this));
    }

    onUnmerge() {
        this._cssObject.removeFromParent();
        this._cssObject = null;
        this._domElement = null;
        this._text = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._cssObject.visible = visible;
    }
}

/* sprites_box_with_text */

class sprites_box_with_text_Transformer {
    static kTrivial = false;
    static kStatic = false;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
        const translateExpr = () => {
            const x = 10 + Math.cos($.timestamp() / 2) * 2.0;
            const z = Math.sin($.timestamp() / 2) * 2.0;
            const result = new THREE.Vector3(z, 1, x);
            return result            

        }
        this._object.position.copy(translateExpr());
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_text extends EntityBase {
        evalProperty__visible() {  // property is static
        return true;
    }


    constructor(entity_id, full_path, assetsManager, parent) {
        super(entity_id, full_path, assetsManager, parent);
        this._children = [
            new sprites_box_with_text_some_box(
                'some-box', '/sprites/box-with-text/some-box',
                assetsManager, this),
            new sprites_box_with_text_label_2d(
                'label-2d', '/sprites/box-with-text/label-2d',
                assetsManager, this),
            new sprites_box_with_text_label_3d(
                'label-3d', '/sprites/box-with-text/label-3d',
                assetsManager, this),
            new sprites_box_with_text_label_3d_faced(
                'label-3d-faced', '/sprites/box-with-text/label-3d-faced',
                assetsManager, this),
        ];
    }

    onStep(sync) {
        super.onStep(sync);
        if (this._visible || sync) {
            for(var key in this._children) {
                this._children[key].onStep(sync);
            }
        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._group = new THREE.Group();
        this._group.visible = this._visible;
        if (viewContainer) {
            viewContainer.add(this._group);
        }
        this.setTransformer(new sprites_box_with_text_Transformer(this._group, this));
        this._subscribedEvents = new Set();
        for(var key in this._children) {
            this._children[key].onEmerge(this._group, guiContainer);
            for(const kind of this._children[key].getSubscribedEvents()) {
                this._subscribedEvents.add(kind);
            }
        }
    }

    onUnmerge() {
        for(var key in this._children) {
            this._children[key].onUnmerge();
        }
        this._group.removeFromParent();
        this._group = null;
        super.onUnmerge();
    }

    onResize(width, height) {
        for(var key in this._children) {
            this._children[key].onResize(width, height);
        }
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._group.visible = visible;
        for(var key in this._children) {
            this._children[key].onVisibleChanged(visible);
        }
    }

    onEventPosted(kind, args) {
        if (this._subscribedEvents.has(kind)) {
            for(var key in this._children) {
                this._children[key].onEventPosted(kind, args);
            }
        }
    }

    getSubscribedEvents() {
        return this._subscribedEvents;
    }

    query(target, params) {
        // TODO: this gaves pretty random result (and non-deterministic in general)
        //       should be weighted somehow according to user-provided hints
        for(var key in this._children) {
            const result = this._children[key].query(target, params);
            if (result) return result;
        }
        return null;
    }

    registerEntity(destination_object) {
        super.registerEntity(destination_object);
        for(var key in this._children) {
            this._children[key].registerEntity(destination_object);
        }
    }

    dump() {
        const children = {};
        for(var key in this._children) {
            const child = this._children[key];
            children[key] = child.dump();
        }
        return {
            ...super.dump(),
            'subtree-children': children,
        };
    }

    restore(state_dump) {
        // TODO: validate state_dump
        super.restore(state_dump);
        for(var key in state_dump['subtree-children']) {
            const child_state = state_dump['subtree-children'][key];
            this._children[key].restore(child_state);
        }
    }
}

/* sprites_box_with_image_some_box_2 */

class sprites_box_with_image_some_box_2_Transformer {
    static kTrivial = true;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_image_some_box_2 extends EntityBase {
        evalProperty__animation() {  // property is static
        return null;
    }
    evalProperty__filename() {  // property is static
        return "mesh.glb";
    }
    evalProperty__visible() {  // property is static
        return true;
    }

        buildMaterial() {
        const parameters = {
            aoMapIntensity: (() => {
                return 1;
            })(),
            bumpScale: (() => {
                return 1;
            })(),
            color: (() => {
                return new THREE.Color(1, 1, 1);
            })(),
            displacementScale: (() => {
                return 1;
            })(),
            emissive: (() => {
                return new THREE.Color(0, 0, 0);
            })(),
            emissiveIntensity: (() => {
                return 1;
            })(),
            envMapIntensity: (() => {
                return 1;
            })(),
            fog: (() => {
                return true;
            })(),
            lightMapIntensity: (() => {
                return 1;
            })(),
            normalMapType: (() => {
                return THREE.TangentSpaceNormalMap;
            })(),
            normalScale: (() => {
                return new THREE.Vector2(1, 1);
            })(),
            roughness: (() => {
                return 1.0;
            })(),
            wireframeLinecap: (() => {
                return "round";
            })(),
            wireframeLinejoin: (() => {
                return "round";
            })(),
            wireframeLinewidth: (() => {
                return 1;
            })(),
        };
        return new THREE.MeshStandardMaterial(parameters);
    }


    recalcMaterialProps(target) {
    }


    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {


            if (this._mixer) {
                this._mixer.update($.dt());
            }
        }
    }

    listAnimations() {
        const result = [];
        for(var i in this._animations) {
            result.push(this._animations[i].name);
        }
        return result;
    }

    // THREE.LoopOnce | THREE.LoopRepeat | THREE.LoopPingPong
    playAnimation(animation, loop = THREE.LoopOnce) {
        if (this._mixer) {
            const clip = THREE.AnimationClip.findByName(this._animations, animation);
            if (clip) {
                const action = this._mixer.clipAction(clip);
                action.reset();
                action.loop = loop;
                action.play();
            } else {
                console.log(`no such animation clip: ${animation}`);
            }
        }
    }

    resetAnimation() {
        this._mixer.stopAllAction();
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._viewContainer = viewContainer;
        this._guiContainer = guiContainer;
        if (this._visible) {
            if (!this._filename) this._filename = this.evalProperty__filename();
            const asset = this._assetsManager.getAsset(this._filename);
            if (!asset) throw Error(`no such mesh: ${this._filename}`)
            this._scene = asset.scene.clone();

            this._scene.userData = {
                'treeNode': this,
            }
            for(var i in this._scene.children) {
                this._scene.children[i].userData = {
                    'treeNode': this,
                }
            }

            this._scene.visible = this._visible;
            if (viewContainer) { // TODO: move to base class
                viewContainer.add(this._scene);
            }
            this.setTransformer(new sprites_box_with_image_some_box_2_Transformer(this._scene, this));

            // NOTE: disable "Group by NLA Track"
            if (asset.animations.length > 0) {
                this._mixer = new THREE.AnimationMixer(this._scene);
                this._animations = asset.animations;
            } else {
                this._mixer = null;
            }

            this._animation = this.evalProperty__animation();
            if (this._animation) {
                this.playAnimation(this._animation, THREE.LoopRepeat);
            }
        }
    }

    onUnmerge() {
        this._filename = null;
        if (this._scene) {
            this._scene.removeFromParent();
        }
        this._scene = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        if (this._scene) {
            this._scene.visible = visible;
        } else {
            // TODO: this is ugly
            this.onEmerge(this._viewContainer, this._guiContainer);
        }
    }
}

/* sprites_box_with_image_image_2d */

class sprites_box_with_image_image_2d_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(0, -2, 0);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_image_image_2d extends EntityBase {
        evalProperty__mode() {  // property is static
        return "2d";
    }
    evalProperty__src() {  // property is static
        return "sprite.png";
    }
    evalProperty__visible() {  // property is static
        return true;
    }

    

    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._domElement = document.createElement('img');

        if (!this._src) this._src = this.evalProperty__src();
        this._domElement.src = this._src;

        const mode = this.evalProperty__mode();
        if (mode === '2d') {
            this._cssObject = new CSS2DObject(this._domElement);
        } else if (mode === '3d-faced') {
            this._cssObject = new CSS3DSprite(this._domElement);
        } else if (mode === '3d') {
            this._cssObject = new CSS3DObject(this._domElement);
        } else {
            throw new Error(`unknown sprite mode: ${mode}`);
        }
        this._cssObject.visible = this._visible;

        if (viewContainer) { // TODO: move to base class
            viewContainer.add(this._cssObject);
        }

        this.setTransformer(new sprites_box_with_image_image_2d_Transformer(this._cssObject, this));
    }

    onUnmerge() {
        this._cssObject.removeFromParent();
        this._cssObject = null;
        this._domElement = null;
        this._text = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._cssObject.visible = visible;
    }
}

/* sprites_box_with_image_image_3d */

class sprites_box_with_image_image_3d_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(0, 2, 0);
        this._object.scale.set(0.05, 0.05, 0.05);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_image_image_3d extends EntityBase {
        evalProperty__mode() {  // property is static
        return "3d";
    }
    evalProperty__src() {  // property is static
        return "sprite.png";
    }
    evalProperty__visible() {  // property is static
        return true;
    }

    

    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._domElement = document.createElement('img');

        if (!this._src) this._src = this.evalProperty__src();
        this._domElement.src = this._src;

        const mode = this.evalProperty__mode();
        if (mode === '2d') {
            this._cssObject = new CSS2DObject(this._domElement);
        } else if (mode === '3d-faced') {
            this._cssObject = new CSS3DSprite(this._domElement);
        } else if (mode === '3d') {
            this._cssObject = new CSS3DObject(this._domElement);
        } else {
            throw new Error(`unknown sprite mode: ${mode}`);
        }
        this._cssObject.visible = this._visible;

        if (viewContainer) { // TODO: move to base class
            viewContainer.add(this._cssObject);
        }

        this.setTransformer(new sprites_box_with_image_image_3d_Transformer(this._cssObject, this));
    }

    onUnmerge() {
        this._cssObject.removeFromParent();
        this._cssObject = null;
        this._domElement = null;
        this._text = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._cssObject.visible = visible;
    }
}

/* sprites_box_with_image_image_3d_faced */

class sprites_box_with_image_image_3d_faced_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(0, 0, 0);
        this._object.scale.set(0.05, 0.05, 0.05);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_image_image_3d_faced extends EntityBase {
        evalProperty__mode() {  // property is static
        return "3d-faced";
    }
    evalProperty__src() {  // property is static
        return "sprite.png";
    }
    evalProperty__visible() {  // property is static
        return true;
    }

    

    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._domElement = document.createElement('img');

        if (!this._src) this._src = this.evalProperty__src();
        this._domElement.src = this._src;

        const mode = this.evalProperty__mode();
        if (mode === '2d') {
            this._cssObject = new CSS2DObject(this._domElement);
        } else if (mode === '3d-faced') {
            this._cssObject = new CSS3DSprite(this._domElement);
        } else if (mode === '3d') {
            this._cssObject = new CSS3DObject(this._domElement);
        } else {
            throw new Error(`unknown sprite mode: ${mode}`);
        }
        this._cssObject.visible = this._visible;

        if (viewContainer) { // TODO: move to base class
            viewContainer.add(this._cssObject);
        }

        this.setTransformer(new sprites_box_with_image_image_3d_faced_Transformer(this._cssObject, this));
    }

    onUnmerge() {
        this._cssObject.removeFromParent();
        this._cssObject = null;
        this._domElement = null;
        this._text = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._cssObject.visible = visible;
    }
}

/* sprites_box_with_image */

class sprites_box_with_image_Transformer {
    static kTrivial = false;
    static kStatic = false;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
        const translateExpr = () => {
            const x = - 10 + Math.cos($.timestamp() / 2) * 2.0;
            const z = Math.sin($.timestamp() / 2) * 2.0;
            const result = new THREE.Vector3(x, 1, z);
            return result            

        }
        this._object.position.copy(translateExpr());
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_box_with_image extends EntityBase {
        evalProperty__visible() {  // property is static
        return true;
    }


    constructor(entity_id, full_path, assetsManager, parent) {
        super(entity_id, full_path, assetsManager, parent);
        this._children = [
            new sprites_box_with_image_some_box_2(
                'some-box-2', '/sprites/box-with-image/some-box-2',
                assetsManager, this),
            new sprites_box_with_image_image_2d(
                'image-2d', '/sprites/box-with-image/image-2d',
                assetsManager, this),
            new sprites_box_with_image_image_3d(
                'image-3d', '/sprites/box-with-image/image-3d',
                assetsManager, this),
            new sprites_box_with_image_image_3d_faced(
                'image-3d-faced', '/sprites/box-with-image/image-3d-faced',
                assetsManager, this),
        ];
    }

    onStep(sync) {
        super.onStep(sync);
        if (this._visible || sync) {
            for(var key in this._children) {
                this._children[key].onStep(sync);
            }
        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._group = new THREE.Group();
        this._group.visible = this._visible;
        if (viewContainer) {
            viewContainer.add(this._group);
        }
        this.setTransformer(new sprites_box_with_image_Transformer(this._group, this));
        this._subscribedEvents = new Set();
        for(var key in this._children) {
            this._children[key].onEmerge(this._group, guiContainer);
            for(const kind of this._children[key].getSubscribedEvents()) {
                this._subscribedEvents.add(kind);
            }
        }
    }

    onUnmerge() {
        for(var key in this._children) {
            this._children[key].onUnmerge();
        }
        this._group.removeFromParent();
        this._group = null;
        super.onUnmerge();
    }

    onResize(width, height) {
        for(var key in this._children) {
            this._children[key].onResize(width, height);
        }
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._group.visible = visible;
        for(var key in this._children) {
            this._children[key].onVisibleChanged(visible);
        }
    }

    onEventPosted(kind, args) {
        if (this._subscribedEvents.has(kind)) {
            for(var key in this._children) {
                this._children[key].onEventPosted(kind, args);
            }
        }
    }

    getSubscribedEvents() {
        return this._subscribedEvents;
    }

    query(target, params) {
        // TODO: this gaves pretty random result (and non-deterministic in general)
        //       should be weighted somehow according to user-provided hints
        for(var key in this._children) {
            const result = this._children[key].query(target, params);
            if (result) return result;
        }
        return null;
    }

    registerEntity(destination_object) {
        super.registerEntity(destination_object);
        for(var key in this._children) {
            this._children[key].registerEntity(destination_object);
        }
    }

    dump() {
        const children = {};
        for(var key in this._children) {
            const child = this._children[key];
            children[key] = child.dump();
        }
        return {
            ...super.dump(),
            'subtree-children': children,
        };
    }

    restore(state_dump) {
        // TODO: validate state_dump
        super.restore(state_dump);
        for(var key in state_dump['subtree-children']) {
            const child_state = state_dump['subtree-children'][key];
            this._children[key].restore(child_state);
        }
    }
}

/* sprites_ambient_light */

class sprites_ambient_light_Transformer {
    static kTrivial = true;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_ambient_light extends EntityBase {
        evalProperty__color() {  // property is static
        return new THREE.Color(0.3, 0.3, 0.3);
    }
    evalProperty__intensity() {  // property is static
        return 0.5;
    }
    evalProperty__visible() {  // property is static
        return true;
    }


    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

            
            
        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._light = new THREE.AmbientLight(this.evalProperty__color(),
                                             this.evalProperty__intensity());
        this._light.visible = this._visible;
        if (viewContainer) {
            viewContainer.add(this._light);
        }
        this.setTransformer(new sprites_ambient_light_Transformer(this._light, this));
    }

    onUnmerge() {
        this._light.removeFromParent();
        this._light.dispose();
        this._light = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._light.visible = visible;
    }
}

/* sprites_point_light */

class sprites_point_light_Transformer {
    static kTrivial = false;
    static kStatic = false;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
        const translateExpr = () => {
            const x = Math.cos($.timestamp() / 5) * 2.0;
            const z = Math.sin($.timestamp() / 5) * 2.0;
            const result = new THREE.Vector3(x, 10, z);
            return result

        }
        this._object.position.copy(translateExpr());
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_point_light extends EntityBase {
        evalProperty__cast_shadow() {  // property is static
        return false;
    }
    evalProperty__color() {  // property is static
        return new THREE.Color(1, 1, 1);
    }
    evalProperty__decay() {  // property is static
        return 2;
    }
    evalProperty__distance() {  // property is static
        return 0;
    }
    evalProperty__intensity() {  // property is static
        return 1.5;
    }
    evalProperty__visible() {  // property is static
        return true;
    }


    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

            
            
            
            
        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._light = new THREE.PointLight(this.evalProperty__color(),
                                           this.evalProperty__intensity(),
                                           this.evalProperty__distance(),
                                           this.evalProperty__decay());
        this._light.visible = this._visible;
        if (viewContainer) {
            viewContainer.add(this._light);
        }
        this.setTransformer(new sprites_point_light_Transformer(this._light, this));
    }

    onUnmerge() {
        this._light.removeFromParent();
        this._light.dispose();
        this._light = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._light.visible = visible;
    }
}

/* sprites_camera */

class sprites_camera_Transformer {
    static kTrivial = false;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
        this._object.position.set(10, 10, 10);
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_camera extends EntityBase {
        evalProperty__far() {  // property is static
        return 1000.0;
    }
    evalProperty__fov() {  // property is static
        return 60;
    }
    evalProperty__look_at() {  // property is static
        return new THREE.Vector3(0, 0, 0);
    }
    evalProperty__near() {  // property is static
        return 0.1;
    }
    evalProperty__visible() {  // property is static
        return true;
    }




    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {

        }
    }

    onResize(width, height) {
        super.onResize(width, height);
        this._camera.aspect = width / height;
        this._camera.updateProjectionMatrix();
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        this._camera = new THREE.PerspectiveCamera(this.evalProperty__fov(),
                                                   $.width() / $.height(),
                                                   this.evalProperty__near(),
                                                   this.evalProperty__far());
        this._camera.visible = this._visible;
        if (viewContainer) {
            viewContainer.add(this._camera);
        }
        this.setTransformer(new sprites_camera_Transformer(this._camera, this));

        this._camera.lookAt(this.evalProperty__look_at());
    }

    onUnmerge() {
        this._camera.removeFromParent();
        this._camera = null;
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        this._camera.visible = visible;
    }

    query(target, params) { return (target == 'camera') ? this._camera : null; }

    dump() {
        // NOTE: these only need correctly dump/restore a Camera that controlled via *Controls
        return {
            ...super.dump(),
            'perspective-camera': this._camera.toJSON(null),
        };
    }

    restore(state_dump) {
        super.restore(state_dump);
        const camera_dump = state_dump['perspective-camera'].object;

        this._camera.aspect = camera_dump.aspect;
        this._camera.far = camera_dump.far;
        this._camera.filmGauge = camera_dump.filmGauge;
        this._camera.filmOffset = camera_dump.filmOffset;
        this._camera.focus = camera_dump.focus;
        this._camera.fov = camera_dump.fov;
        //this._camera.layers: 1
        this._camera.near = camera_dump.near;
        this._camera.zoom = camera_dump.zoom;

        const matrix = new THREE.Matrix4();
        matrix.fromArray(camera_dump.matrix);
        this._camera.matrixAutoUpdate = false;
        this._camera.matrix = new THREE.Matrix4();
        this._camera.applyMatrix4(matrix);
        this._camera.matrixAutoUpdate = true;
    }
}

/* sprites_controls */

class sprites_controls_Transformer {
    static kTrivial = true;
    static kStatic = true;

    constructor(object, entity) {
        this._object = object;
        this._entity = entity;
    }

    initValues() {
        this.eval_statics();
        this.eval_dynamics();
    }

    updateValues() {
        this.eval_dynamics();
    }

    eval_statics() {
    }

    eval_dynamics() {
    }

    // API to mimic Entity

    getFullPath() { return this._entity._full_path; }

    getEntityId() { return this._entity._entity_id; }
}
class sprites_controls extends EntityBase {
        evalProperty__damping_factor() {  // property is static
        return 0.05;
    }
    evalProperty__enable_damping() {  // property is static
        return false;
    }
    evalProperty__enable_pan() {  // property is static
        return true;
    }
    evalProperty__enable_rotate() {  // property is static
        return true;
    }
    evalProperty__enable_zoom() {  // property is static
        return true;
    }
    evalProperty__key_pan_speed() {  // property is static
        return 7.0;
    }
    evalProperty__max_azimuth_angle() {  // property is static
        return Infinity;
    }
    evalProperty__max_distance() {  // property is static
        return Infinity;
    }
    evalProperty__max_polar_angle() {  // property is static
        return 3.141592653589793;
    }
    evalProperty__max_zoom() {  // property is static
        return Infinity;
    }
    evalProperty__min_azimuth_angle() {  // property is static
        return -Infinity;
    }
    evalProperty__min_distance() {  // property is static
        return 0;
    }
    evalProperty__min_polar_angle() {  // property is static
        return 0;
    }
    evalProperty__min_zoom() {  // property is static
        return 0;
    }
    evalProperty__pan_speed() {  // property is static
        return 1;
    }
    evalProperty__rotate_speed() {  // property is static
        return 1;
    }
    evalProperty__visible() {  // property is static
        return true;
    }
    evalProperty__zoom_speed() {  // property is static
        return 1;
    }




    onStep(sync) {
        super.onStep(sync);
        if (this._visible) {
            const camera = $.camera();

            if (this._controls && camera &&
                this._controls.object.id != camera.id)
            {
                this.onUnmerge();
            }

            if (!this._controls && camera) {
                this.onEmerge(); // TODO: wtf?? where is parameters??
            }

            if (this._controls && camera) {
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                this._controls.update();
            }
        }
    }

    onEmerge(viewContainer, guiContainer) {
        super.onEmerge(viewContainer, guiContainer);
        const camera = $.camera();
        const renderer = $.renderer();
        if (camera && renderer) {
            this._controls = new OrbitControls(camera, renderer.domElement);
            this._controls.enabled = this._visible;
            this._controls.damping_factor = this.evalProperty__damping_factor();

            this._controls.enable_damping = this.evalProperty__enable_damping();

            this._controls.enable_pan = this.evalProperty__enable_pan();

            this._controls.enable_rotate = this.evalProperty__enable_rotate();

            this._controls.enable_zoom = this.evalProperty__enable_zoom();

            this._controls.key_pan_speed = this.evalProperty__key_pan_speed();

            this._controls.max_azimuth_angle = this.evalProperty__max_azimuth_angle();

            this._controls.max_distance = this.evalProperty__max_distance();

            this._controls.max_polar_angle = this.evalProperty__max_polar_angle();

            this._controls.max_zoom = this.evalProperty__max_zoom();

            this._controls.min_azimuth_angle = this.evalProperty__min_azimuth_angle();

            this._controls.min_distance = this.evalProperty__min_distance();

            this._controls.min_polar_angle = this.evalProperty__min_polar_angle();

            this._controls.min_zoom = this.evalProperty__min_zoom();

            this._controls.pan_speed = this.evalProperty__pan_speed();

            this._controls.rotate_speed = this.evalProperty__rotate_speed();

            this._controls.zoom_speed = this.evalProperty__zoom_speed();


            if (this._pended_restore) {
                this._controls.target.fromArray(this._pended_restore.target);
                this._pended_restore = null;
            }
        }
    }

    onUnmerge() {
        if (this._controls) {
            this._controls.dispose();
            this._controls = null;
        }
        super.onUnmerge();
    }

    onVisibleChanged(visible) {
        super.onVisibleChanged(visible);
        if (this._controls) {
            this._controls.enabled = visible;
        }
    }

    dump() {
        const result = {
            ...super.dump(),

        };
        if (this._controls) {
            result['orbit-controls'] = {
                'target': this._controls.target.toArray(),
            }
        }
        return result;
    }

    restore(state_dump) {
        super.restore(state_dump);
        this._pended_restore = state_dump['orbit-controls'];
    }
}

/* Assets manager */

const kAssetsToPreload = [
    'mesh.glb',
];

const kPending = 1;
const kSucceeded = 2;
const kFailed = 3;

export class AssetsManager {
    constructor(successCallback) {
        this._store = {};
        this._gltfLoader = new GLTFLoader();
        this._textureLoader = new THREE.TextureLoader();
        this._loadingState = kPending;

        const assetsManager = THREE.DefaultLoadingManager;
        assetsManager.onStart = () => {
            console.log("Assets loading started");
        };
        assetsManager.onLoad = () => {
            console.log("Assets loading done");
            if (this._loadingState == kFailed) {
                console.log("application loading failed!");
            } else {
                this._loadingState = kSucceeded;
                successCallback();
            }
        };
        assetsManager.onError = (url) => {
            console.log(`loading of "${url}" is failed`);
            this._loadingState = kFailed;
        };
    }

    start = () => {
        console.log('start AssetsManager');
        const scope = this;
        if (kAssetsToPreload.length > 0)
        {
            for(const assetId in kAssetsToPreload) {
                const url = kAssetsToPreload[assetId];
                const extension = url.split('.').pop().toLowerCase()
                var loader = null;

                if (extension == 'glb' || extension == 'gltf') {
                    loader = this._gltfLoader;
                } else if (extension == 'png' || extension == 'jpg' || extension == 'jpeg') {
                    loader = this._textureLoader;
                } else {
                    throw Error(`unknown asset type, url = '${url}', extension = '${extension}'`)
                }

                loader.load(
                    url,
                    (loadedAsset) => { scope._store[url] = loadedAsset; },
                    (xhr) => { console.log(`loading ${url}: ${xhr.loaded/xhr.total*100}`); },
                    (error) => { console.log(`an error occured while loading ${url}: ${error}`); },
                );

            }
        } else {
            const assetsManager = THREE.DefaultLoadingManager;
            assetsManager.onLoad();
        }
    }

    getLoadingManager = () => { return THREE.DefaultLoadingManager; }

    getAsset = (id) => { return this._store[id]; }
}

/* Reload manager */

class ReloadManager {
    constructor(main, state_id) {
        const scope = this;

        this._polling_interval = 1000;
        this._current_revision = null;
        this._main = main;
        this._state_id = state_id;

        this._code_revision_poller = new XMLHttpRequest();
        this._code_revision_poller.onload = (e) => {
            if (e.target.status == 200) {
                const response = JSON.parse(e.target.responseText);
                if (scope._current_revision != null && scope._current_revision != response.revision) {
                    scope.reload();
                }
                if (scope._current_revision == null) {
                    console.log(`initial version ${response.revision}`);
                }
                scope._current_revision = response.revision;
                scope._polling_interval = response.polling_interval;
            } else {
                console.warn(`failed to poll code revision: ${e.target.status}`)
            }

            setTimeout(() => { scope.poll(); },
                       scope._polling_interval);
        };

        this.poll();
    }

    poll = () => {
        this._code_revision_poller.open(
            'GET', 'http://127.0.0.1:8000/__ncjsam__/code-revision', true);
        this._code_revision_poller.send();
    }

    reload = () => {
        // create a state dump
        console.log('reloading page');
        const state = this._main.dump();

        // store the state
        const save_request = new XMLHttpRequest();
        save_request.open(
            'POST', `http://127.0.0.1:8000/__ncjsam__/states/${this._state_id}`, false);
        save_request.setRequestHeader('Content-Type', 'application/json');
        save_request.send(JSON.stringify(
            {
                'contents': state,
            }
        ));

        // call for rebuild
        const rebuild_request = new XMLHttpRequest();
        rebuild_request.open(
            'POST', `http://127.0.0.1:8000/__ncjsam__/rebuild-prefix`, false);
        rebuild_request.setRequestHeader('Content-Type', 'application/json');
        rebuild_request.send(JSON.stringify({}))

        // reload the window
        window.location.replace(
            `http://127.0.0.1:8000/?state_id=${encodeURIComponent(this._state_id)}`
        );
    }

    maybe_restore_state = () => {
        const request = new XMLHttpRequest();
        request.open(
            'GET', `http://127.0.0.1:8000/__ncjsam__/states/${this._state_id}`, false);
        request.setRequestHeader('Content-Type', 'application/json');
        request.send();
        if (request.status == 200) {
            const response = JSON.parse(request.responseText);
            this._main.restore(response.contents);
        }
    }
}


/* Main class */

export class Main {
    constructor() {
        // common initializations
        this._assetsManager = null;
        this._clock = new THREE.Clock();
        this._wallclock = 0;
        this._renderer = new THREE.WebGLRenderer();
        this._renderer.setSize(window.innerWidth, window.innerHeight);
        this._css2renderer = new CSS2DRenderer();
        this._css2renderer.setSize(window.innerWidth, window.innerHeight);
        this._css2renderer.domElement.style.position = 'absolute';
        this._css2renderer.domElement.style.top = '0px';
        this._css2renderer.domElement.style.pointerEvents = 'none';
        this._css3renderer = new CSS3DRenderer();
        this._css3renderer.setSize(window.innerWidth, window.innerHeight);
        this._css3renderer.domElement.style.position = 'absolute';
        this._css3renderer.domElement.style.top = '0px';
        this._css3renderer.domElement.style.pointerEvents = 'none';
        this._camera = null;
        this._scene = new THREE.Scene();
        this._controls = null;
        this._rootEntities = null;
        this._lastDt = null;
        this._eventQueue = [];
        this._subscribedEvents = new Set();
        this._pointerRaycaster = new THREE.Raycaster();
        this._pointerRaycasterPointer = new THREE.Vector2();
        this._pointerRaycasterIntersections = null;

        const url = new URL(window.location.href);
        const query = new URLSearchParams(url.search);
        this._state_id = query.has('state_id') ? query.get('state_id')
                                               : self.crypto.randomUUID();
        console.log(`state_id = ${this._state_id}`)

        this._guiLayer = document.createElement('div');
        this._guiLayer.style.background = 'rgba(0, 0, 0, 0)';
        this._guiLayer.style.border = '0px';
        this._guiLayer.style.width = '100%';
        this._guiLayer.style.height = '100%';
        this._guiLayer.style.position = 'absolute';
        this._guiLayer.style.userSelect = 'none';
        this._guiLayer.style.pointerEvents = 'none';
        this._guiLayer.setAttribute('draggable', false);

        document.body.appendChild(this._guiLayer);
        document.body.appendChild(this._renderer.domElement);
        document.body.appendChild(this._css2renderer.domElement);
        document.body.appendChild(this._css3renderer.domElement);
        
        addEventListener('resize', this.resize);
        addEventListener('pointermove', this.updatePointer);
    }

    init = (assetsManager) => {
        console.log('init Main');
        $.__setMain(this);

        // store items
        this._assetsManager = assetsManager;

        // create entities
        this._rootEntities = [
            new sprites_debug_grid(
                'debug-grid', '/sprites/debug-grid',
                this._assetsManager, null),
            new sprites_box_with_text(
                'box-with-text', '/sprites/box-with-text',
                this._assetsManager, null),
            new sprites_box_with_image(
                'box-with-image', '/sprites/box-with-image',
                this._assetsManager, null),
            new sprites_ambient_light(
                'ambient-light', '/sprites/ambient-light',
                this._assetsManager, null),
            new sprites_point_light(
                'point-light', '/sprites/point-light',
                this._assetsManager, null),
            new sprites_camera(
                'camera', '/sprites/camera',
                this._assetsManager, null),
            new sprites_controls(
                'controls', '/sprites/controls',
                this._assetsManager, null),
        ];
        this.registerEntities($);

        // init entities
        for(var i in this._rootEntities) {
            this._rootEntities[i].onEmerge(this._scene, this._guiLayer);
        }

        for(var i in this._rootEntities) {
            for(const kind of this._rootEntities[i].getSubscribedEvents()) {
                this._subscribedEvents.add(kind);
            }
        }

        // maybe reload state
        this._reloadManager = new ReloadManager(this, this._state_id);
        this._reloadManager.maybe_restore_state();

        // init event queue
        this._eventQueue = [{
            'kind': 'ncjsam-init',
            'args': {},
        }];
        this.renewSystemSubscriptions();
    }

    renewSystemSubscriptions = () => {
        const systemEvents = new Set([
            'keydown', 'keyup',
            'pointercancel', 'pointerdown', 'pointermove', 'pointerup',
            'touchcancel', 'touchend', 'touchmove', 'touchstart',
            'wheel',
            'dblclick',
            'resize',
            'load', 'DOMContentLoaded',
        ])
        for(const kind of this._subscribedEvents) {
            if (systemEvents.has(kind)) {
                addEventListener(kind, (event) => {
                    this.enqueue(event.type, event);
                });
            }
        }
    }

    getCamera = () => { return this._camera; }

    getRenderer = () => { return this._renderer; }

    getPointerIntersections = () => {
        // TODO: maybe just guarantee a presence of a camera?
        if (!this._pointerRaycasterIntersections && this._camera) {
            this._pointerRaycaster.setFromCamera(this._pointerRaycasterPointer,
                                                 this._camera);
            this._pointerRaycasterIntersections = (
                this._pointerRaycaster.intersectObjects(this._scene.children));
        }
        return this._pointerRaycasterIntersections;
    }

    updatePointer = (event) => {
        this._pointerRaycasterPointer.x =  (event.clientX / window.innerWidth) * 2 - 1;
        this._pointerRaycasterPointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    resize = (event) => {
        if (this._camera) {
            // TODO: this duplicates update inside the Camera Entity
            this._camera.aspect = window.innerWidth / window.innerHeight;
            this._camera.updateProjectionMatrix();
        }
        this._renderer.setSize(window.innerWidth, window.innerHeight);
        this._css2renderer.setSize(window.innerWidth, window.innerHeight);
        this._css3renderer.setSize(window.innerWidth, window.innerHeight);
        for(var i in this._rootEntities) {
            this._rootEntities[i].onResize(window.innerWidth,
                                           window.innerHeight);
        }
    }

    enqueue = (kind, args) => {
        this._eventQueue.push({'kind': kind, 'args': args});
    }

    advance = () => {
        // update state
        this._lastDt = this._clock.getDelta(); // seconds
        this._wallclock += this._lastDt;
        this._pointerRaycasterIntersections = null;

        // process events
        if (this._eventQueue.length > 0) {
            for(var event_index in this._eventQueue) {
                const event = this._eventQueue[event_index];
                for(var entity_index in this._rootEntities) {
                    this._rootEntities[entity_index].onEventPosted(event.kind,
                                                                   event.args);
                }
            }
            this._eventQueue = [];
        }

        // update camera
        var camera = null;
        for(var i in this._rootEntities) {
            this._rootEntities[i].onStep(false);
            if (!camera) {
                camera = this._rootEntities[i].query('camera', null);
            }
        }
        this._camera = camera; // TODO: don't update everytime

        // update controls
        if (this._controls) {
            this._controls.update();
        }

        // update physics step
        if (this._physicsWorld) {
            this._physicsWorld.stepSimulation(this._lastDt, 10);
        }

        // render a frame
        if (this._scene && this._camera) {
            this._renderer.render(this._scene, this._camera);
            this._css2renderer.render(this._scene, this._camera);
            this._css3renderer.render(this._scene, this._camera);
        } else {
            console.warn('not rendering due to abscence scene and/or camera, scene = ',
                         this._scene, ', camera = ', this._camera);
        }
    }

    getWallclock = () => { return this._wallclock; }
    getLastDt = () => { return this._lastDt; }
    registerEntities = (destination_object) => {
        for (var i in this._rootEntities) {
            this._rootEntities[i].registerEntity(destination_object);
        }
    }

    rootEntity = (key) => {
        // TODO: use dict instead list
        for(var i in this._rootEntities) {
            if (this._rootEntities[i].getFullPath() == key) {
                return this._rootEntities[i];
            }
        }
        return null;
    }

    dump = () => {
        const rootEntities = {};
        for (var i in this._rootEntities) {
            const entity = this._rootEntities[i];
            rootEntities[entity.getFullPath()] = entity.dump();
        }

        return {
            'ncjsam-dump': '0.1',
            'wallclock': this._wallclock,
            'last-dt': this._lastDt,
            'event-queue': this._eventQueue,
            'root-entities': rootEntities,
        }
    }

    restore = (state) => {
        console.log('state to restore', state);

        if (state['ncjsam-dump'] != '0.1') {
            throw Error(`unexpected dump version: "${state['ncjsam-dump']}"`)
        }

        this._wallclock = state['wallclock'];
        this._lastDt = state['last-dt'];
        this._eventQueue = state['event-queue'];
        for(var key in state['root-entities']) {
            const entityState = state['root-entities'][key];
            this.rootEntity(key).restore(entityState);
        }

        for(var i in this._rootEntities) {
            this._rootEntities[i].onStep(true);
        }
    }
}